<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIlury Programming Studio</title>
    <style>
        body {
            background: #fcfcfc;
	    width: 100vw;
	    overflow-x: hidden;
        }
        .code-editor-container {
            height: 80vh;
            width: 100vw;
            border-radius: 5px;
            background: #fff;
	    padding: 5px 3em;
	    overflow-y: scroll;
	    box-shadow: inset 0px 0px 10px #fcfcfc;
        }
        .code-editor-line {
            display: inline-block;
            position: relative;
            border-radius: 5px;
            background: #fff;
            color: #000;
            font-size: 1em;
            font-family: "Fira Code", "JetBrains Mono", monospace;
            letter-spacing: 0.06em;
            text-align: left;
            padding: 5px;
            transition: 0.5s;
            white-space: pre-wrap;
            width: 100%;
            box-sizing: border-box;
            cursor: pointer;
        }
        .code-editor-line:focus {
            outline: none;
            background: #f0f0f0;
        }
        .code-editor-line {
            counter-increment: line-number;
            position: relative;
        }
        .code-editor-line::before {
            content: counter(line-number) ". ";
            position: absolute;
            right: 101%;
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 0.7em;
            border: none;
            color: #999999;
        }
        /* Checkmark style */
        .code-editor-line.selected::after {
            content: '✓';
            position: absolute;
            left: -3.5em;
            top: 0;
            color: #28a745;
            font-size: 1.2em;
        }
        /* Selected line styling */
        .code-editor-line.selected {
            background-color: #e0f7e9;
            transform: translateX(1.5em); /* Slight movement to the right */
	    border-radius: 0;
        }
        .code-editor-line.selected.topSelected {
	    border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0; /* Falls du die untere rechte Ecke ebenfalls abgerundet haben möchtest */
        }

        .code-editor-line.selected.bottomSelected {
	    border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            border-top-left-radius: 0;
            border-top-right-radius: 0; /* Falls du die obere rechte Ecke ebenfalls abgerundet haben möchtest */
        }

        .code-editor-line.selected.middleSelected {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0; /* Entfernt alle Ecken */
        }

        .code-editor-line.selected.singleSelected {
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px; /* Rundet alle Ecken */
        }

	.suggestion-container {
            position: absolute;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .suggestion {
            padding: 5px;
            cursor: pointer;
        }
        .suggestion:hover {
            background-color: #ddd;
        }
    </style>
</head>
<body>
    <div class="code-editor-container">
        <div id="1" class="code-editor-line" contenteditable="true"></div>
	<div id="suggestion-box" class="suggestion-container"></div>
    </div>

    <script>
        let startX, startLine;

        // Allgemeiner Event Listener für Touch-Events
        document.addEventListener('touchstart', function(event) {
            // Überprüfen, ob das Element eine Linie ist
            let target = event.target.closest('.code-editor-line');
            if (target) {
                startX = event.touches[0].clientX;  // Startkoordinate speichern
                startLine = target;  // Die Zeile speichern, auf der der Touch gestartet wurde
            }
        });

        document.addEventListener('touchend', function(event) {
            if (!startLine) return;  // Keine Linie gestartet, nichts tun

            let endX = event.changedTouches[0].clientX;  // Endkoordinate speichern
            let diffX = endX - startX;  // Unterschied zwischen Start und Ende berechnen

            // Wenn nach rechts geswiped wird und auf derselben Zeile geendet wird
            if (diffX > 50) {
                startLine.classList.add('selected');  // Linie auswählen
                updateSelectedClasses();
            } else if (diffX < -50 && startLine.classList.contains('selected')) {
                startLine.classList.remove('selected');  // Linie abwählen bei links Swipe
                updateSelectedClasses();
            }

            startLine = null;  // Touch-Zustand zurücksetzen
        });
		
	let correntids = 1;
        let inputDiv = document.querySelector('.code-editor-container');

        // Paste Event-Listener
        inputDiv.addEventListener('paste', function(event) {
            event.preventDefault(); // Verhindert das Standardverhalten des Einfügens

            let celine = document.querySelector('.code-editor-line:focus');
            if (!celine) return;

	    let spaces = "";
            let continueSpaces = true;
            for (let i = 0; i < celine.textContent.length; i++) {
                let character = celine.textContent[i];
                if ((character === " " || character === "\u00A0") && continueSpaces) {
                    spaces += "&nbsp;";
                } else {
                    continueSpaces = false;
                }
            }
            // Kopierten Text aus der Zwischenablage holen
            let pasteText = (event.clipboardData || window.clipboardData).getData('text');

            // Aufteilen des eingefügten Textes bei Zeilenumbrüchen
            let lines = pasteText.split(/\r\n|\n|\r/);

            let selection = window.getSelection();
            let range = selection.getRangeAt(0);
            let cursorOffset = range.startOffset;

            // Text vor dem Cursor behalten und Text nach dem Cursor extrahieren
            let currentText = celine.textContent;
            let textAfterCursor = currentText.substring(cursorOffset);
            celine.textContent = currentText.substring(0, cursorOffset);

            // Verarbeite die erste Linie: Der Text wird in die aktuelle Linie eingefügt
            celine.innerText += convertToNonBreakingSpaces(lines[0]);

            // Für die folgenden Zeilen, füge sie als neue Linien (divs) hinzu
            for (let i = 1; i < lines.length; i++) {
                correntids += 1;
                const newline = document.createElement('div');
                newline.setAttribute('contenteditable', 'true');
                newline.id = correntids;
                newline.classList.add('code-editor-line');
		newline.innerHTML = spaces;
                newline.innerText += convertToNonBreakingSpaces(lines[i]);
                celine.insertAdjacentElement('afterend', newline);
                celine = newline;
            }

            // Text nach dem Cursor in die letzte Linie einfügen
            celine.innerText += convertToNonBreakingSpaces(textAfterCursor);

            // Setze den Cursor ans Ende der letzten Linie
            const newRange = document.createRange();
            newRange.setStart(celine.childNodes[0], celine.childNodes[0].length);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
        });

        // Hilfsfunktion, um Leerzeichen in &nbsp; zu konvertieren
        function convertToNonBreakingSpaces(text) {
            return text.replace(/ /g, ' ').replace(/\t/g, '    '/*'&nbsp;&nbsp;&nbsp;&nbsp;'*/); // Konvertiert Leerzeichen und Tabs in nicht-brechende Leerzeichen
        }

        // Enter- und Backspace-Event-Listener
        inputDiv.addEventListener('keydown', function(event) {
            let celine = document.querySelector('.code-editor-line:focus');
			
            if (event.key === 'Enter') {
                event.preventDefault(); // Verhindert das Standardverhalten der Enter-Taste

                if (celine) {
                    correntids += 1;
                    const newid = correntids;

                    let text = celine.textContent;
                    let selection = window.getSelection();
                    let range = selection.getRangeAt(0);
                    let cursorOffset = range.startOffset;

                    let textBehindCursor = text.substring(cursorOffset);
                    celine.textContent = text.substring(0, cursorOffset);

                    let spaces = "";
                    let continueSpaces = true;
                    for (let i = 0; i < celine.textContent.length; i++) {
                        let character = celine.textContent[i];
                        if ((character === " " || character === "\u00A0") && continueSpaces) {
                            spaces += "&nbsp;";
                        } else {
                            continueSpaces = false;
                        }
                    }

                    const newline = document.createElement('div');
                    newline.setAttribute('contenteditable', 'true');
                    newline.id = newid;
                    newline.classList.add('code-editor-line');
                    newline.innerHTML = spaces;

                    celine.insertAdjacentElement('afterend', newline);
                    newline.innerText += textBehindCursor;

                    newline.focus();
                    range = document.createRange();
                    range.setStart(newline.childNodes[0], newline.childNodes[0].length - textBehindCursor.length);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
		    updateSelectedClasses();
                }
            }

            // Backspace-Taste
            if (event.key === 'Backspace') {
                let selection = window.getSelection();
                let range = selection.getRangeAt(0);

                if (range.startOffset === 0 && celine) {
                    event.preventDefault();

                    const previousLine = celine.previousElementSibling;
                    if (previousLine) {
			updateSelectedClasses();
                        let currentLineText = celine.textContent;

                        celine.remove();
                        previousLine.textContent += currentLineText;

                        previousLine.focus();
                        range = document.createRange();
                        range.setStart(previousLine.childNodes[0], previousLine.childNodes[0].length - currentLineText.length);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            }
			
	    if (event.key === '>') {
        	 let selection = window.getSelection();
        	 let range = selection.getRangeAt(0);
        	 let cursorOffset = range.startOffset;

      		 // Holen des aktuellen Texts vor dem Cursor
       		 let text = celine.textContent.substring(0, cursorOffset);
       		 // Prüfen, ob der Text einen öffnenden Tag enthält
        	 let openTagMatch = text.match(/<(\w+)([^>]*)$/);

       		 if (openTagMatch) {
            		event.preventDefault(); // Verhindert das Standardverhalten

            		// Tag automatisch schließen
           		 let tagName = openTagMatch[1];
           		 let tagEnd = `</${tagName}>`;

          		  // Fügen Sie den schließenden Tag direkt nach dem Cursor ein
          		  let textAfterCursor = celine.textContent.substring(cursorOffset);
          		  celine.textContent = text + '>' + tagEnd + textAfterCursor;

           		 // Setzen Sie den Cursor zwischen die Tags
           		 range.setStart(celine.firstChild, cursorOffset + 1);
           		 range.collapse(true);
           		 selection.removeAllRanges();
          		 selection.addRange(range);
       		 }
    	    }
			
	    let selection = window.getSelection();
   
	    let range = selection.getRangeAt(0);
	    let cursorOffset = range.startOffset;
            
            // Erstellen einer Funktion, die das aktuelle Zeichen schließt
            function insertClosingCharacter(openingChar, closingChar) {
                let text = celine.textContent;
                let textAfterCursor = text.substring(cursorOffset);
                celine.textContent = text.substring(0, cursorOffset) + openingChar + closingChar + textAfterCursor;

                // Cursor zwischen den Zeichen platzieren
                range.setStart(celine.firstChild, cursorOffset + 1);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }

            // Automatisches Schließen von '{'
            if (event.key === '{') {
                event.preventDefault();
                insertClosingCharacter('{', '}');
            }
			
			if (event.key === '[') {
                event.preventDefault();
                insertClosingCharacter('[', ']');
            }

            // Automatisches Schließen von '('
            if (event.key === '(') {
                event.preventDefault();
                insertClosingCharacter('(', ')');
            }

            // Automatisches Schließen von '`'
            if (event.key === '`') {
                event.preventDefault();
                insertClosingCharacter('`', '`');
            }

            // Automatisches Schließen von '„'
            if (event.key === '„') {
                event.preventDefault();
                insertClosingCharacter('"', '"');
            }

            // Automatisches Schließen von '‚'
            if (event.key === '‚') {
                event.preventDefault();
                insertClosingCharacter('\'', '\'');
            }
			
	    if (event.key === '"') {
                event.preventDefault();
                insertClosingCharacter('"', '"');
            }

            // Automatisches Schließen von '‚'
            if (event.key === "'") {
                event.preventDefault();
                insertClosingCharacter('\'', '\'');
            }
			
	    function checkAndSkipClosingCharacter(closingChar) {
	        let text = celine.textContent;
		let nextChar = text.charAt(cursorOffset);
		if (nextChar === closingChar) {
		    event.preventDefault();
		    range.setStart(celine.firstChild, cursorOffset + 1);
		    range.collapse(true);
		    selection.removeAllRanges();
		    selection.addRange(range);
	        }
	    }

	    if (event.key === ']') {
	        checkAndSkipClosingCharacter(']');
	    }
	    if (event.key === '}') {
		checkAndSkipClosingCharacter('}');
	    }
	    if (event.key === '"') {
	        checkAndSkipClosingCharacter('"');
	    }
	    if (event.key === "'") {
		checkAndSkipClosingCharacter("'");
	    }
	    if (event.key === ')') {
		checkAndSkipClosingCharacter(')');
	    }
	    if (event.key === ';') {
		checkAndSkipClosingCharacter(';');
	    }
	});
        function updateSelectedClasses() {
            const lines = document.querySelectorAll('.code-editor-line');

            lines.forEach((line, index) => {
                const isSelected = line.classList.contains('selected');

                // Überprüfen, ob es über und unter der Zeile selektierte Zeilen gibt
                const hasAbove = index > 0 && lines[index - 1].classList.contains('selected');
                const hasBelow = index < lines.length - 1 && lines[index + 1].classList.contains('selected');

                // Entfernen aller relevanten Klassen
		if (line.classList.contains('topSelected')){
		    line.classList.remove('topSelected');
		}
		if (line.classList.contains('bottomSelected')){
		    line.classList.remove('bottomSelected');
		}
		if (line.classList.contains('middleSelected')){
		    line.classList.remove('middleSelected');
		}
		if (line.classList.contains('singleSelected')){
		    line.classList.remove('singleSelected');
		}

                if (isSelected) {
                    if (!hasAbove && !hasBelow) {
                        // Single selected
                        line.classList.add('singleSelected');
                    } else if (!hasAbove && hasBelow) {
                        // Top selected
                        line.classList.add('topSelected');
                    } else if (hasAbove && !hasBelow) {
                        // Bottom selected
                        line.classList.add('bottomSelected');
                    } else if (hasAbove && hasBelow) {
                        // Middle selected
                        line.classList.add('middleSelected');
                    }
                }
            });
        }












	const jsKeywords = [
    // Schlüsselwörter
    "abstract", "arguments", "await", "boolean", "break", "byte", "case", "catch",
    "char", "class", "const", "continue", "debugger", "default", "delete", "do",
    "double", "else", "enum", "eval", "export", "extends", "false", "final",
    "finally", "float", "for", "function", "goto", "if", "implements", "import",
    "in", "instanceof", "int", "interface", "let", "long", "native", "new",
    "null", "package", "private", "protected", "public", "return", "short",
    "static", "super", "switch", "synchronized", "this", "throw", "throws",
    "transient", "true", "try", "typeof", "var", "void", "volatile", "while",
    "with", "yield",

    // Globale Objekte
    "Array", "ArrayBuffer", "Boolean", "DataView", "Date", "Error", "EvalError",
    "Float32Array", "Float64Array", "Function", "Generator", "GeneratorFunction",
    "Infinity", "Int16Array", "Int32Array", "Int8Array", "Intl", "JSON", "Map",
    "Math", "NaN", "Number", "Object", "Promise", "Proxy", "RangeError",
    "ReferenceError", "Reflect", "RegExp", "Set", "SharedArrayBuffer",
    "String", "Symbol", "SyntaxError", "TypeError", "URIError", "Uint16Array",
    "Uint32Array", "Uint8Array", "Uint8ClampedArray", "WeakMap", "WeakSet",
    "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent",
    "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "unescape",

    // Kontrollstrukturen
    "if", "else", "switch", "case", "default", "for", "while", "do", "break",
    "continue", "try", "catch", "finally", "throw", "return",

    // DOM-Methoden
    "getElementById", "getElementsByClassName", "getElementsByTagName", "querySelector",
    "querySelectorAll", "addEventListener", "removeEventListener", "createElement",
    "appendChild", "removeChild", "setAttribute", "getAttribute", "classList.add",
    "classList.remove", "classList.toggle", "classList.contains", "innerHTML",
    "textContent", "style"
        ];

	const cssKeywords = [
    // CSS Eigenschaften
    "align-content", "align-items", "align-self", "all", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "backface-visibility", "background",
    "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin",
    "background-position", "background-repeat", "background-size", "border",
    "border-bottom", "border-bottom-color", "border-bottom-left-radius",
    "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
    "border-collapse", "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color", "border-left-style",
    "border-left-width", "border-radius", "border-right", "border-right-color",
    "border-right-style", "border-right-width", "border-spacing", "border-style",
    "border-top", "border-top-color", "border-top-left-radius",
    "border-top-right-radius", "border-top-style", "border-top-width",
    "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",
    "caption-side", "caret-color", "clear", "clip", "color", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style",
    "column-rule-width", "column-span", "column-width", "columns", "content",
    "counter-increment", "counter-reset", "cursor", "direction", "display",
    "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow",
    "flex-grow", "flex-shrink", "flex-wrap", "float", "font", "font-family",
    "font-feature-settings", "font-kerning", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant", "font-weight",
    "gap", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",
    "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",
    "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",
    "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows",
    "height", "justify-content", "left", "letter-spacing", "line-height", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "max-height", "max-width", "min-height", "min-width", "opacity", "outline",
    "overflow", "padding", "position", "right", "text-align", "text-decoration",
    "text-shadow", "top", "transform", "transition", "width", "z-index",

    // CSS Pseudoklassen
    ":active", ":checked", ":disabled", ":empty", ":enabled", ":first-child",
    ":first-of-type", ":focus", ":hover", ":in-range", ":invalid", ":last-child",
    ":last-of-type", ":link", ":not", ":nth-child", ":nth-last-child", ":nth-last-of-type",
    ":nth-of-type", ":only-child", ":only-of-type", ":optional", ":out-of-range",
    ":read-only", ":read-write", ":required", ":root", ":target", ":valid", ":visited",

    // CSS Pseudoelemente
    "::after", "::before", "::first-letter", "::first-line", "::marker", "::selection", "::placeholder"
        ];


	const htmlKeywords = [
    // HTML Tags
    "a", "abbr", "address", "area", "article", "aside", "audio", "b", "base",
    "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption",
    "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details",
    "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption",
    "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head",
    "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins",
    "kbd", "label", "legend", "li", "link", "main", "map", "mark", "meta",
    "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output",
    "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby",
    "s", "samp", "script", "section", "select", "small", "source", "span",
    "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody",
    "td", "template", "textarea", "tfoot", "th", "thead", "time", "title",
    "tr", "track", "u", "ul", "var", "video", "wbr",

    // HTML Attribute
    "accept", "accept-charset", "action", "align", "alt", "async", "autocomplete",
    "autofocus", "checked", "cite", "class", "cols", "content", "contenteditable",
    "controls", "coords", "data-*", "datetime", "default", "defer", "disabled",
    "download", "enctype", "for", "form", "formaction", "headers", "height",
    "hidden", "high", "href", "hreflang", "http-equiv", "id", "label",
    "lang", "list", "loop", "low", "manifest", "max", "maxlength", "min",
    "minlength", "multiple", "name", "novalidate", "open", "optimum", "pattern",
    "placeholder", "poster", "preload", "readonly", "rel", "required", "reversed",
    "rows", "rowspan", "sandbox", "scope", "selected", "shape", "size", "sizes",
    "span", "src", "srcdoc", "srclang", "start", "style", "tabindex",
    "target", "title", "type", "value", "width", "wrap"
        ];

        const allKeywords = [...jsKeywords, ...cssKeywords, ...htmlKeywords];
        const suggestionBox = document.getElementById('suggestion-box');
        const editor = document.querySelector('.code-editor-line:focus');

        inputDiv.addEventListener('keydown', function(event) {
	    if (!editor){
		return;
	    }
            const cursorPosition = getCursorPosition(editor);
            const word = getWordBeforeCursor(editor, cursorPosition);

            if (word.length > 0) {
                showSuggestions(word);
            } else {
                suggestionBox.style.display = 'none';
            }

            if (event.key === 'Tab' && suggestionBox.style.display !== 'none') {
                event.preventDefault();
                const selectedSuggestion = document.querySelector('.suggestion');
                if (selectedSuggestion) {
                    insertSuggestion(selectedSuggestion.textContent, editor, cursorPosition);
                    suggestionBox.style.display = 'none';
                }
            }
        });

        function getCursorPosition(editor) {
            const selection = window.getSelection();
            return selection.anchorOffset;
        }

        function getWordBeforeCursor(editor, cursorPosition) {
            const text = editor.textContent;
            const words = text.substring(0, cursorPosition).split(' ');
            return words[words.length - 1];
        }

        function showSuggestions(word) {
            const suggestions = allKeywords.filter(keyword => keyword.startsWith(word));
            suggestionBox.innerHTML = '';

            if (suggestions.length > 0) {
                suggestions.forEach(suggestion => {
                    const div = document.createElement('div');
                    div.textContent = suggestion;
                    div.classList.add('suggestion');
                    div.addEventListener('click', function() {
                        insertSuggestion(suggestion, editor, getCursorPosition(editor));
                    });
                    suggestionBox.appendChild(div);
                });
                const rect = editor.getBoundingClientRect();
                suggestionBox.style.left = `${rect.left}px`;
                suggestionBox.style.top = `${rect.bottom}px`;
                suggestionBox.style.display = 'block';
            } else {
                suggestionBox.style.display = 'none';
            }
        }

        function insertSuggestion(suggestion, editor, cursorPosition) {
            const text = editor.textContent;
            const words = text.substring(0, cursorPosition).split(' ');
            words[words.length - 1] = suggestion;
            editor.textContent = words.join(' ') + text.substring(cursorPosition);
            setCaretPosition(editor, cursorPosition + suggestion.length - words[words.length - 1].length);
        }

        function setCaretPosition(editor, position) {
            const range = document.createRange();
            const selection = window.getSelection();
            range.setStart(editor.childNodes[0], position);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    </script>
</body>
</html>
